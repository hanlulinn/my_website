---
categories:
- ""
- ""
date: "2017-10-31T22:26:13-05:00"
description: Nullam et orci eu lorem consequat tincidunt vivamus et sagittis magna
  sed nunc rhoncus condimentum sem. In efficitur ligula tate urna. Maecenas massa
  sed magna lacinia magna pellentesque lorem ipsum dolor. Nullam et orci eu lorem
  consequat tincidunt. Vivamus et sagittis tempus.
draft: false
image: pic06.jpg
keywords: ""
slug: project1
title: Project 1 - Applied Statistics
---

```{r, setup, echo=FALSE}
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE, 
  tidy=FALSE,
  size="small")
options(digits = 3)

knitr::opts_chunk$set(
  fig.width=6.75, 
  fig.height=6.75,
  fig.align = "center"
)
```

```{r load-libraries, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(mosaic)
library(ggthemes)
library(lubridate)
library(fivethirtyeight)
library(here)
library(skimr)
library(janitor)
library(vroom)
library(tidyquant)
library(rvest)
```

# Where Do People Drink The Most Beer, Wine And Spirits?

Back in 2014,
[fivethiryeight.com](https://fivethirtyeight.com/features/dear-mona-followup-where-do-people-drink-the-most-beer-wine-and-spirits/)
published an article on alchohol consumption in different countries. The
data `drinks` is available as part of the `fivethirtyeight` package.
Make sure you have installed the `fivethirtyeight` package before
proceeding.

```{r, load_alcohol_data}
library(fivethirtyeight)
data(drinks)
```

What are the variable types? Any missing values we should worry about?

There is 1 character variable and 4 numeric variables. No missing
values to worry about.

```{r glimpse_skim_data}
drinks %>% skim #Skim the data for variable types and missing values.
```

There is 1 character variable and 4 numeric variables. No missing values to worry about.


Make a plot that shows the top 25 beer consuming countries

```{r beer_plot}
#Create a plot to show the top 25 beer consuming countries
drinks %>%
  slice_max(order_by=beer_servings, n=25) %>%  #Select the top 25 beer consuming countries data
  ggplot(aes(x=beer_servings, y=reorder(country,beer_servings))) + # Plot the data, descending order
  geom_col() +
  theme_bw() +
  labs(title='Beer Consumption by Country', subtitle= 'Top 25', x='Servings (per person)', y='Country') + 
  NULL
```

Make a plot that shows the top 25 wine consuming countries

```{r wine_plot}
#Create a plot to show the top 25 wine consuming countries
drinks %>%
  slice_max(order_by=wine_servings, n=25) %>% #Select the top 25 wine consuming countries
  ggplot(aes(x=wine_servings, y=reorder(country, wine_servings)))+ # Plot the data, descending order
  geom_col() +
  theme_bw() +
  labs(title='Wine Consumption by Country',subtitle= 'Top 25', x='Servings (per person)', y='Country') + 
  NULL
```

Finally, make a plot that shows the top 25 spirit consuming countries

```{r spirit_plot}
#Create a plot to show the top 25 spirit consuming countries
drinks %>%
  slice_max(order_by=spirit_servings, n=25) %>% #Select the top 25 spirit consuming countries
  ggplot(aes(x=spirit_servings, y=reorder(country,spirit_servings))) + # Plot the data, descending order
  geom_col() +
  theme_bw() +
  labs(title='Spirit Consumption by Country', subtitle= 'Top 25', x='Servings (per person)', y='Country') + 
  NULL
```

What can you infer from these plots? Don't just explain what's in the
graph, but speculate or tell a short story (1-2 paragraphs max).

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

Rudimental factors that affect consumption of beer, wine, and spirit
include production levels, drinking age limit, pricing, and culture.

Based on the data, it can be observed that beer consumption is the
highest for Namibia, Czech Republic, Gabon, and Germany. This can
perhaps be attributed to the beer triangle in Namibia, low-cost beer in
Czech Republic (cheaper than water), and the lowest drinking age in
Germany (16 as opposed to 18 for other countries) (Kohli 2021, Nugent
2021) .

As for wine consumption, France (370 wine servings), Portugal, Andorra,
and Switzerland top the list while Ireland is in position 25, at 150
servings. The distribution of the 25 countries seems to have high
variance.

Lastly, similar to the wine consumption distribution, spirit consumption
also appears to have high variance. While Grenada has a high consumption
of spirits perhaps due to culture (women have higher per capita
consumption than men) and Belarus due to the relaxed policies, Mongolia
may have lower consumption as they prefer their regional fermented milk
alcohol drinks (OECD 2020).

# Analysis of movies- IMDB dataset

We will look at a subset sample of movies, taken from the [Kaggle IMDB
5000 movie
dataset](https://www.kaggle.com/carolzhangdc/imdb-5000-movie-dataset)

```{r load_movies, warning=FALSE, message=FALSE}
movies <- read_csv(here::here("data", "movies.csv"))
glimpse(movies)
```

Besides the obvious variables of `title`, `genre`, `director`, `year`,
and `duration`, the rest of the variables are as follows:

-   `gross` : The gross earnings in the US box office, not adjusted for
    inflation
-   `budget`: The movie's budget
-   `cast_facebook_likes`: the number of facebook likes cast memebrs
    received
-   `votes`: the number of people who voted for (or rated) the movie in
    IMDB
-   `reviews`: the number of reviews for that movie
-   `rating`: IMDB average rating

## Use your data import, inspection, and cleaning skills to answer the following:

-   Are there any missing values (NAs)? Are all entries distinct or are
    there duplicate entries?

```{r}
paste('Missing values:', sum(is.na(movies))) #Check missing values
paste('Duplicate values:', sum(duplicated(movies))) #Check duplicated values
```

-   Produce a table with the count of movies by genre, ranked in
    descending order

```{r}
movies %>%
  group_by(genre) %>%
  count(sort=T)
```

-   Produce a table with the average gross earning and budget (`gross`
    and `budget`) by genre. Calculate a variable `return_on_budget`
    which shows how many \$ did a movie make at the box office for each
    \$ of its budget. Ranked genres by this `return_on_budget` in
    descending order

```{r}
#Create a table with the average gross earning and budget (`gross` and `budget`) by genre
movies %>%
  group_by(genre) %>% #Group data by genre
  summarise(
    meanGross=mean(gross),
    meanBudget=mean(budget)) %>%
  mutate(return_on_budget=(meanGross-meanBudget)/meanBudget,
         across(return_on_budget, round, 2)) %>% #Calculate return on budget data, round to 2 decimal places
  arrange(-return_on_budget) #Ranked genres by return on budget in descending order
```

-   Produce a table that shows the top 15 directors who have created the
    highest gross revenue in the box office. Don't just show the total
    gross amount, but also the mean, median, and standard deviation per
    director.

```{r}
#Produce a table that shows the top 15 directors who have created the highest gross revenue in the box office
movies %>%
  group_by(director) %>% #Group data by directors
  summarise(
    total=sum(gross),
    mean=mean(gross),
    median=median(gross),
    sd=sd(gross)) %>% #Calculate mean,median,sd per director
  slice_max(order_by=total, n=15) #Select the top 15 highest gross revenue data, order by total 
```

-   Finally, ratings. Produce a table that describes how ratings are
    distributed by genre. We don't want just the mean, but also, min,
    max, median, SD and some kind of a histogram or density graph that
    visually shows how ratings are distributed.

```{r}
#Calculate median,min,max,and sd of ratings
movies %>%
  group_by(genre) %>% #Group data by genre
  summarise(
    mean=mean(rating),
    min=min(rating),
    max=max(rating),
    median=median(rating),
    sd=sd(rating)) %>% 
  mutate(across(2:6, round, 2)) # round columns 2 through 6 to 2 decimal places

#Create histogram that shows how ratings are distributed by genre
movies %>%
  ggplot(aes(x=rating)) +
  geom_histogram(binwidth=0.5) +
  facet_wrap(~genre) +
  theme_bw() +
  labs(title='Rating distribution by genre', x='Rating', y='Number of movies') + 
  NULL
```

## Use `ggplot` to answer the following

-   Examine the relationship between `gross` and `cast_facebook_likes`.
    Produce a scatterplot and write one sentence discussing whether the
    number of facebook likes that the cast has received is likely to be
    a good predictor of how much money a movie will make at the box
    office. What variable are you going to map to the Y- and X- axes?

```{r, gross_on_fblikes}
#Create scatterplot to examine the relationship between gross and cast_facebook_likes
movies %>%
  ggplot(aes(x=cast_facebook_likes, y=gross, alpha=.01)) + #Make the points opaque to see where there are denser areas
  geom_point() +
  geom_smooth() +
  scale_x_log10() + #log the x & y axes to see a clearer snapshot of what is occurring 
  scale_y_log10() +
  theme_bw() +
  labs(title='Relationship Between Gross Profit and Facebook Likes', x='Facebook Likes', y='Gross Profit') + 
  theme(legend.position = "none") +
  NULL
```

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

The x-axis depicts the Facebook likes and the y-axis gross profits.
While the data show a slight positive correlation between Facebook Likes
and Gross Profit, there is immense variability, so Facebook likes do not
seem to be a strong predictor of the money a movie makes. Mapping other
variables could help determine what truly impacts the money a movie
makes.

-   Examine the relationship between `gross` and `budget`. Produce a
    scatterplot and write one sentence discussing whether budget is
    likely to be a good predictor of how much money a movie will make at
    the box office.

```{r, gross_on_budget}
#Create scatterplot to examine the relationship between gross and budget
movies %>%
  ggplot(aes(x=budget, y=gross, alpha=.01)) + #Make the points opaque to see where there are denser areas
  geom_point() +
  geom_smooth() +
  theme_bw() +
  labs(title='Relationship Between Gross Profit and Budget', x='Budget', y='Gross Profit') +
  theme(legend.position = "none") +
  NULL
```

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

Compared to the previous plot, this plot shows a higher correlation
between budget and gross profit; however, there is still much
variability and we cannot conclude that the relationship is significant.

-   Examine the relationship between `gross` and `rating`. Produce a
    scatterplot, faceted by `genre` and discuss whether IMDB ratings are
    likely to be a good predictor of how much money a movie will make at
    the box office. Is there anything strange in this dataset?

```{r, gross_on_rating}
#Create scatterplot to examine the relationship between gross and ratings, faceted by genre
movies %>%
  ggplot(aes(x=rating, y=gross)) +
  geom_point() +
  facet_wrap(~genre) +
  theme_bw() +
  labs(title='Relationship Between Gross Profit and Rating', subtitle= 'By Genre', x='Rating', y='Gross Profit') + 
  NULL
```

Our hypothesis before examining the data was that rating would be a good
predictor of gross profit. While we see that is the case for Action,
Adventure, and perhaps Drama, there are other genres that did not align
with our hypothesis. Documentaries, for example, do not see a gross
profit of greater than 200 mil but they do have high ratings. This makes
sense because while Documentary films tend to have high ratings due to
the realness of their topics, they are not popular films to see in the
theaters.

There are irregularities in the dataset that these plots depict.
Firstly, it seems that the dataset is highly imbalanced as there are
very few data points for family, musical, romance, thriller, and western
films. Next, it looks as though some genres have low gross profits
compared to others, when historically those genres actually produce
highly. For example, the Star Wars films are one of the highest grossing
Sci-Fi films, and films in general, but the data do not reflect this.
This may be due to the data only assigning one genre to a movie, so a
movie like Star Wars would be assigned Action, rather than Sci-Fi.

# Returns of financial stocks

> You may find useful the material on [finance data
> sources](https://mam2022.netlify.app/reference/finance_data/).

We will use the `tidyquant` package to download historical data of stock
prices, calculate returns, and examine the distribution of returns.

We must first identify which stocks we want to download data for, and
for this we must know their ticker symbol; Apple is known as AAPL,
Microsoft as MSFT, McDonald's as MCD, etc. The file `nyse.csv` contains
508 stocks listed on the NYSE, their ticker `symbol`, `name`, the IPO
(Initial Public Offering) year, and the sector and industry the company
is in.

```{r load_nyse_data, message=FALSE, warning=FALSE}
nyse <- read_csv(here::here("data","nyse.csv"))
glimpse(nyse)
```

Based on this dataset, create a table and a bar plot that shows the
number of companies per sector, in descending order

```{r companies_per_sector}
#Create table for numbers of companies per sector in descending order
nyse %>%
  group_by(sector) %>%
  count(sort=T)

#Create bar plot for numbers of companies per sector in descending order
nyse %>%
  group_by(sector) %>%
  count(sort=T) %>%
  ggplot(aes(x=n, y=fct_reorder(sector, n))) +
  geom_col() +
  theme_bw() +
  labs(title='Number of Stocks By Sector', x='Number of Stocks', y='Sector') + 
  NULL
```

Next, let's choose some stocks and their ticker symbols and download
some data. You **MUST** choose 6 different stocks from the ones listed
below; You should, however, add `SPY` which is the SP500 ETF (Exchange
Traded Fund).

```{r get_price_data, message=FALSE, warning=FALSE, cache=TRUE}
myStocks <- c("AAPL","JPM","DIS","DPZ","ANF","SPY") %>%
  tq_get(get  = "stock.prices",
         from = "2011-01-01",
         to   = "2021-08-31") %>%
  group_by(symbol) 

glimpse(myStocks)
```

Financial performance analysis depend on returns; If I buy a stock today
for 100 and I sell it tomorrow for 101.75, my one-day return, assuming
no transaction costs, is 1.75%. So given the adjusted closing prices,
our first step is to calculate daily and monthly returns.

```{r calculate_returns, message=FALSE, warning=FALSE, cache=TRUE}
#calculate daily returns
myStocks_returns_daily <- myStocks %>%
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = "daily", 
               type       = "log",
               col_rename = "daily_returns",
               cols = c(nested.col))  

#calculate monthly  returns
myStocks_returns_monthly <- myStocks %>%
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = "monthly", 
               type       = "arithmetic",
               col_rename = "monthly_returns",
               cols = c(nested.col)) 

#calculate yearly returns
myStocks_returns_annual <- myStocks %>%
  group_by(symbol) %>%
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = "yearly", 
               type       = "arithmetic",
               col_rename = "yearly_returns",
               cols = c(nested.col))

```

Create a table where you summarise monthly returns for each of the
stocks and `SPY`; min, max, median, mean, SD.

```{r summarise_monthly_returns}
#Create a table that summarise min, max, median, mean, SD of monthly returns for each of the stock
myStocks_returns_monthly %>%
  group_by(symbol) %>%
  summarise(
    min=min(monthly_returns),
    max=max(monthly_returns),
    median=median(monthly_returns),
    mean=mean(monthly_returns),
    sd=sd(monthly_returns)) %>% 
  mutate(across(2:6, round, 3)) #round for easier understanding
```

Plot a density plot, using `geom_density()`, for each of the stocks

```{r density_monthly_returns}
#Create a density plot for each stocks
myStocks_returns_monthly %>%
  ggplot(aes(x=monthly_returns, colour=symbol, fill=symbol)) + 
  geom_density(alpha=0.3) +
  facet_wrap(~symbol) +
  theme_bw() +
  theme(legend.position='none') +
  labs(title='Density Plot of Monthly Returns', x='Return', y='Density') +
  NULL
```

What can you infer from this plot? Which stock is the riskiest? The
least risky?

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

Plotting the monthly returns for the stocks of various companies over
time helps us determine the level of risk involved in such investments.
According to the density plot, the *most* risky stock is **ANF** and the
*least* risky is **SPY**.

Finally, make a plot that shows the expected monthly return (mean) of a
stock on the Y axis and the risk (standard deviation) in the X-axis.
Please use `ggrepel::geom_text_repel()` to label each stock

```{r risk_return_plot}
#Create a plot to identify the expected monthly return(mean) and rish(SD) of each stock
myStocks_returns_monthly %>%
  group_by(symbol) %>%
  summarise(
    sd=sd(monthly_returns),
    mean=mean(monthly_returns)) %>%
  ggplot(aes(x=sd, y=mean, label=symbol)) + #Add the stock symbol as the label for each point
  geom_point() +
  theme_bw() +
  ggrepel::geom_text_repel() + #Label each stock
  labs(title='Risk and Return Plot for Selected Stocks', x='Risk', y='Return') +
  NULL
```

What can you infer from this plot? Are there any stocks which, while
being riskier, do not have a higher expected return?

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

This plot depicts the risk-return relationship of each stock. While DPZ
provides the highest return for a moderate risk level, ANF, despite
being the riskiest, provides the least amount of return.

# On your own: IBM HR Analytics

For this task, you will analyse a data set on Human Resoruce Analytics.
The [IBM HR Analytics Employee Attrition & Performance data
set](https://www.kaggle.com/pavansubhasht/ibm-hr-analytics-attrition-dataset)
is a fictional data set created by IBM data scientists. Among other
things, the data set includes employees' income, their distance from
work, their position in the company, their level of education, etc. A
full description can be found on the website.

First let us load the data

```{r}
#Load the data
hr_dataset <- read_csv(here::here("data", "datasets_1067_1925_WA_Fn-UseC_-HR-Employee-Attrition.csv"))
glimpse(hr_dataset)
```

I am going to clean the data set, as variable names are in capital
letters, some variables are not really necessary, and some variables,
e.g., `education` are given as a number rather than a more useful
description

```{r}
#Clean the data set
hr_cleaned <- hr_dataset %>%
  clean_names() %>% 
  mutate(
    education = case_when(
      education == 1 ~ "Below College",
      education == 2 ~ "College",
      education == 3 ~ "Bachelor",
      education == 4 ~ "Master",
      education == 5 ~ "Doctor"),
    environment_satisfaction = case_when(
      environment_satisfaction == 1 ~ "Low",
      environment_satisfaction == 2 ~ "Medium",
      environment_satisfaction == 3 ~ "High",
      environment_satisfaction == 4 ~ "Very High"),
    job_satisfaction = case_when(
      job_satisfaction == 1 ~ "Low",
      job_satisfaction == 2 ~ "Medium",
      job_satisfaction == 3 ~ "High",
      job_satisfaction == 4 ~ "Very High"),
    performance_rating = case_when(
      performance_rating == 1 ~ "Low",
      performance_rating == 2 ~ "Good",
      performance_rating == 3 ~ "Excellent",
      performance_rating == 4 ~ "Outstanding"),
    work_life_balance = case_when(
      work_life_balance == 1 ~ "Bad",
      work_life_balance == 2 ~ "Good",
      work_life_balance == 3 ~ "Better",
      work_life_balance == 4 ~ "Best")) %>% 
  select(age, attrition, daily_rate, department,
         distance_from_home, education,
         gender, job_role,environment_satisfaction,
         job_satisfaction, marital_status,
         monthly_income, num_companies_worked, percent_salary_hike,
         performance_rating, total_working_years,
         work_life_balance, years_at_company,
         years_since_last_promotion)
hr_cleaned
```

Produce a one-page summary describing this dataset. Here is a
non-exhaustive list of questions:

1.  How often do people leave the company (`attrition`)?

```{r HR question1}
hr_cleaned %>%
  summarize(
    count_yes=count(attrition == 'Yes'), 
    count_total=count(attrition)) %>%
  mutate(proportion=count_yes/count_total, #Find the number of yes attrition/total attrition to find the proportion of people leaving the company
         across(proportion, round, 3)) %>% #round
  select(proportion)
```

2.  How are `age`, `years_at_company`, `monthly_income` and
    `years_since_last_promotion` distributed? Can you roughly guess
    which of these variables is closer to Normal just by looking at
    summary statistics?

```{r HR uestion2}
hr_cleaned %>%
  select(age, years_at_company, monthly_income, years_since_last_promotion) %>%
  summary
```

3.  How are `job_satisfaction` and `work_life_balance` distributed?
    Don't just report counts, but express categories as % of total?

```{r HR question3}
#Calculate the total number of employees
total <- nrow(hr_cleaned) 

#Calculate the % of total of each job_satisfaction categories 
hr_cleaned %>%
  group_by(job_satisfaction) %>%
  count() %>%
  mutate(proportion=n/total, 
         across(proportion, round, 3)) %>% #round
  select(proportion)

#Calculate the % of total of each work_life_balance categories
hr_cleaned %>%
  group_by(work_life_balance) %>%
  count() %>%
  mutate(proportion=n/total, 
         across(proportion, round, 3)) %>% #round
  select(proportion)
```

4.  Is there any relationship between monthly income and education?
    Monthly income and gender?

```{r HR question4}
#Create a box plot to examine the relationship between monthly income and education
hr_cleaned %>%
  ggplot(aes(x=monthly_income, y=reorder(education, monthly_income))) +
  geom_boxplot() +
  theme_bw() +
  labs(title='Relationship Between Education and Monthly Income', x='Monthly Income', y='Education') +
  NULL

#Create a box plot to examine the relationship between monthly income and gender
hr_cleaned %>%
  ggplot(aes(x=monthly_income, y=reorder(gender, monthly_income))) +
  geom_boxplot() +
  theme_bw() +
  labs(title='Relationship Between Gender and Monthly Income', x='Monthly Income', y='Gender') +
  NULL
```

5.  Plot a boxplot of income vs job role. Make sure the highest-paid job
    roles appear first.

```{r HR question5}
#Create a box plot to examine the relationship between monthly income and job role
hr_cleaned %>%
  ggplot(aes(x=monthly_income, y=reorder(job_role, monthly_income))) + #Make the job roles appear in descending order of monthly income
  geom_boxplot() +
  theme_bw() +
  labs(title='Relationship Between Job Role and Monthly Income', x='Monthly Income', y='Job Role') +
  NULL
```

6.  Calculate and plot a bar chart of the mean (or median?) income by
    education level.

```{r HR question6}
#Create a bar chart of mean income by education level
hr_cleaned %>%
  group_by(education) %>%
  summarise(mean=mean(monthly_income)) %>% #Calculate the mean income
  ggplot(aes(x=education, y=mean)) +
  geom_col() +
  theme_bw() +
  labs(title='Relationship Between Education and Average Monthly Income', x='Education', y='Average Monthly Income') +
  NULL
```

7.  Plot the distribution of income by education level. Use a facet_wrap
    and a theme from `ggthemes`.

```{r HR question7}
#Create a density plot of monthly income by education level, faceted by education level
hr_cleaned %>%
  ggplot(aes(x=monthly_income, colour=education, fill=education)) +
  geom_density(alpha=0.3) +
  facet_wrap(~education) +
  theme_solid() +
  theme(legend.position='none', text=element_text(size=10)) +
  labs(title='Density Plot of Monthly Income', subtitle='By Education Level', x='Monthly Income', y='Density') +
  NULL
```

8.  Plot income vs age, faceted by `job_role`.

```{r HR question8}
#Create a scatter plot if income vs age, facted by job roles
hr_cleaned %>%
  ggplot(aes(y=monthly_income, x=age, color=job_role)) +
  facet_wrap(~job_role) +
  geom_point() +
  theme(legend.position='none') +
  labs(title='Relationship Between Age and Monthly Income', subtitle='By Job Role', x='Monthly Income', y='Age') +
  NULL
```

> TYPE YOUR ANSWER AFTER (AND OUTSIDE!) THIS BLOCKQUOTE.

After analysis of the IBM HR Analytics Employee Attrition & Performance
Data, we discovered interesting information that may be useful for
senior leaders and HR departments to utilize when making decisions to
improve the company.

We looked at statistics regarding employee satisfaction, work-life
balance, and attrition. Looking at the proportion of job satisfaction,
ranked in terms of Very High, High, Medium, or Low, we found that the
percentage of employees that ranked Very High and High job satisfaction
is 61.3% which is a substantial value. However, the percentage of
employees that ranked Low is quite high at 19.7%. The IBM HR department
should investigate and work on ways to improve this value, at least to a
Medium. It would also be worthwhile for the company to keep the data
year by year and see if/how job satisfaction improves. Next, we looked
at the proportion of work-life balance, a natural indicator of job
satisfaction, which was ranked in terms of Best, Better, Good, and Bad.
The percentage of employees that said bad is very low at 5.44%. However,
we believe that since job satisfaction and work-life balance are so
closely related, that both should be on the same scale of Very High,
High, Medium, or Low. This would make it easier for the HR department to
compare the data and it would give employees the opportunity to rank
their work-life balance as Medium. Last in relation to employee
satisfaction, we looked at employee turnover. We found that the turnover
rate is 19.2% which is generally low; however, it is slightly higher
compared to the average turnover rate for technology companies in the UK
in 2019, which is 18.3% (Munss 2019).

We also looked at plots to compare the relationship between income and
other variables, such as education, gender, job role, and age. The
relationship between income and education is as expected, with the
highest education (doctor) attaining higher income. Then, in descending
order, master, bachelor, college, and below college, as expected.
However, there are outliers in each of the education levels below doctor
that reach high income levels at the same or even higher income than
doctor. These outliers are great as they indicate that employees with
lower education still have the opportunity to reach high income levels
and should be used by the HR department when hiring people of different
education levels. Another great observation was the relationship between
income and gender which is very similar for males and females, with
females achieving slightly higher income than males. This information
should be shared when hiring and celebrated within the company. We also
looked at the relationship between income and job role which was
somewhat as expected. Managers and Research Directors have much higher
income than the other roles, as their seniority and responsibilities is
greater. Then Healthcare Representatives, Manufacturing Directors, Sales
Executives come next with similar incomes, followed by Human Resources,
Research Scientists, Laboratory Technicians, and Sales Representatives
at the bottom of the income ladder. While the order of income by job
role makes sense, there is high variability within each role, which does
not make much sense. For employees with the same role, IBM should look
at the data and try to lower the variability in income to create higher
equality for their employees. Lastly, we looked at the relationship of
income and age, grouped by job role. For most job roles, there is a
small positive correlation between income and age; however, for
Laboratory Technicians, Research Scientists, and Sales Representatives,
there is very little. This tells us that income at IBM has more to do
with the actual role than the age, which is understandable.

Lastly, we looked at summary statistics about age, income, years at
company, and years since last promotion. Based on the summary
statistics, we guessed that income and age would follow a distribution
similar to a normal distribution because the mean and the median are
closely aligned. When we actually looked at the density plots, only one
of our hypothesis was correct: age. The other variables are highly
skewed right, meaning the majority of IBM has lower income, years at
company, and years since last promotion.

# Challenge 1: Replicating a chart

The purpose of this exercise is to reproduce a plot using your `dplyr`
and `ggplot2` skills. Read the article [The Racial Factor: There's 77
Counties Which Are Deep Blue But Also Low-Vaxx. Guess What They Have In
Common?](https://acasignups.net/21/07/18/racial-factor-theres-77-counties-which-are-deep-blue-also-low-vaxx-guess-what-they-have)
and have a look at the attached figure.

```{r challenge1, echo=FALSE, out.width="90%"}
knitr::include_graphics(here::here('images', 'vaxxes_by_state_red_blue_every_county_070321_1.jpeg'), error=FALSE)
```

You dont have to worry about the blue-red backgound and don't worry
about replicating it exactly, try and see how far you can get. You're
encouraged to work together if you want to and exchange tips/tricks you
figured out-- and even though the figure in the original article is from
early July 2021, you can use the most recent data.

Some hints to get you started:

1.  To get vaccination by county, we will use [data from the
    CDC](https://data.cdc.gov/Vaccinations/COVID-19-Vaccinations-in-the-United-States-County/8xkx-amqh)
2.  You need to get [County Presidential Election Returns
    2000-2020](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/VOQCHQ)
3.  Finally, you also need an estimate of the [population of each
    county](https://www.ers.usda.gov/webdocs/DataFiles/48747/PopulationEstimates.csv?v=2232)

```{r echo=FALSE, cache=TRUE}
# Download CDC vaccination by county
cdc_url <- 'https://data.cdc.gov/api/views/8xkx-amqh/rows.csv?accessType=DOWNLOAD'
vaccinations <- vroom(cdc_url) %>% 
  janitor::clean_names() %>% 
  filter(fips != 'UNK') # remove counties that have an unknown (UNK) FIPS code

# Download County Presidential Election Returns
# https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/VOQCHQ
election2020_results <- vroom(here::here('data', 'countypres_2000-2020.csv')) %>% 
  janitor::clean_names() %>% 
  
  # just keep the results for the 2020 election
  filter(year == '2020') %>% 
  
  # change original name county_fips to fips, to be consistent with the other two files
  rename (fips = county_fips)

# Download county population data
population_url <- 'https://www.ers.usda.gov/webdocs/DataFiles/48747/PopulationEstimates.csv?v=2232'
population <- vroom(population_url) %>% 
  janitor::clean_names() %>% 
  
  # select the latest data, namely 2019
  select(fips = fip_stxt, pop_estimate_2019) %>% 
  
  # pad FIPS codes with leading zeros, so they are always made up of 5 characters
  mutate(fips = stringi::stri_pad_left(fips, width=5, pad='0'))
```

The below code creates a graph similar to that on the ACASignups website
on Trump supporters and COVID vaccination rates:

```{r chall1}
#Cleaning the election result data 
results_cleaned <- election2020_results %>%
  filter(candidate == 'DONALD J TRUMP', mode == 'TOTAL') %>% #Filtering for Donald Trump and Mode = Total since total is the default ballot mode in the US
  select(fips, candidatevotes, totalvotes) %>% #Selecting relevant columns 
  mutate(percentage_trump=candidatevotes/totalvotes*100) %>% #Creating a new column for percentage of people who voted for Trump
  select(-candidatevotes, -totalvotes) #Getting rid of unnecessary columns

#Cleaning the vaccination data 
vaccinations_cleaned <- vaccinations %>% 
  filter(date == '07/04/2021') %>% #Filtering for July 4, 2021
  mutate(
    pct_vaccinated=case_when(
      recip_state %in% c('CA', 'GA', 'IA', 'MI', 'TX') ~ administered_dose1_pop_pct,
      T ~ series_complete_pop_pct)) %>% #Taking administered_dose1_pop_pct as the pct_vaccinated for CA, GA, IA, MI, and TX as says in the original plot
  select(fips, pct_vaccinated) %>% #Getting rid of unnecessary columns
  filter(pct_vaccinated > 0.0) #Filtering out pct_vaccinated = 0%

#Merging election result data and vaccination data 
data <- results_cleaned %>%
  inner_join(population, by='fips') %>%
  inner_join(vaccinations_cleaned, by='fips') %>%
  filter()

#Graphing the data (Muster 2021). 
data %>%
  ggplot(aes(x=percentage_trump, y=pct_vaccinated)) +
  geom_point(size=0.5) + #Adjusting point size to 0.5
  geom_point(aes(size=pop_estimate_2019), colour='blue', alpha=0.25) + #Adding circles with size based on population size in 2019 in opaque blue 
  geom_hline(yintercept=85, linetype='dashed', color='black') + #Including Herd Immunity threshold at 85%
  annotate('text', x=23, y=87, label="Herd Immunity threshold (?)") +
  geom_hline(yintercept=53.9, linetype='dashed', color='black') + #Including Target threshold at 53.9% 
  annotate('text', x=15.5, y=55.9, label="Target: 53.9%") +
  geom_hline(yintercept=50.8, linetype='dashed', color='black') + #Including Actual threshold at 50.8% 
  annotate('text', x=15.5, y=52.8, label="Actual: 50.8%") +
  theme_bw() +
  theme(legend.position='none') +
  labs(title='COVID-19 VACCINATION LEVELS OUT OF TOTAL POPULATION BY COUNTY', subtitle='(most states based on FULLY vaccinated only; CA, GA, IA, MI & TX based on total doses administered)', x='2020 Trump Vote %', y='% of Total Population Vaccinated') + #Title and subtitle
  scale_size_continuous(range=c(1, 20)) + #Scaling the graph 
  scale_x_continuous(breaks=seq(0, 100, 5)) +
  scale_y_continuous(breaks=seq(0, 100, 5)) +
  NULL
```

# Challenge 2: Opinion polls for the 2021 German elections

The Guardian newspaper has an [election poll tracker for the upcoming
German
election](https://www.theguardian.com/world/2021/aug/20/german-election-poll-tracker-who-will-be-the-next-chancellor).
The list of the opinion polls since Jan 2021 can be found at
[Wikipedia](https://en.wikipedia.org/wiki/Opinion_polling_for_the_2021_German_federal_election)
and the task is to reproduce the graph similar to the one produced by
the Guardian.

The following code will scrape the wikipedia page and import the table
in a dataframe.

```{r, scrape_wikipedia_polling_data, warnings= FALSE, message=FALSE}
url <- "https://en.wikipedia.org/wiki/Opinion_polling_for_the_2021_German_federal_election"
# https://www.economist.com/graphic-detail/who-will-succeed-angela-merkel
# https://www.theguardian.com/world/2021/jun/21/german-election-poll-tracker-who-will-be-the-next-chancellor

# get tables that exist on wikipedia page
tables <- url %>% 
  read_html() %>% 
  html_nodes(css="table")

# parse HTML tables into a dataframe called polls 
# Use purr::map() to create a list of all tables in URL
polls <- map(tables, . %>% 
             html_table(fill=TRUE)%>% 
             janitor::clean_names())

# list of opinion polls
german_election_polls <- polls[[1]] %>% # the first table on the page contains the list of all opinions polls
  slice(2:(n()-1)) %>%  # drop the first row, as it contains again the variable names and last row that contains 2017 results
  mutate(
         # polls are shown to run from-to, e.g. 9-13 Aug 2021. We keep the last date, 13 Aug here, as the poll date
         # and we extract it by picking the last 11 characters from that field
         end_date = str_sub(fieldwork_date, -11),
         # end_date is still a string, so we convert it into a date object using lubridate::dmy()
         end_date = dmy(end_date),
         # we also get the month and week number from the date, if we want to do analysis by month- week, etc.
         month = month(end_date),
         week = isoweek(end_date))
```

The below text will produce a graph of the opinion poll similar to that
by the Guardian:

```{r chall2}
#Select only necessary columns of the dataset
german_election_polls_cleaned <- german_election_polls %>%
  select(end_date, union, spd, af_d, fdp, linke, grune)

#Assigning colors to each political party, extracted from original plot using adobe color 
col_union <- 'black'
col_spd <- '#BF0404'
col_af_d <- '#8C1F7A'
col_fdp <- '#F2AE2E'
col_linke <- '#0A5789'
col_grune <- '#45BF41'

#Plotting the election outcomes
plot <- german_election_polls_cleaned %>%
  ggplot +
  geom_point(aes(x=end_date, y=union, colour='black')) + #Union Party points assigned the color black
  geom_smooth(aes(x=end_date, y=union), colour='black', span=0.09, se=F) + #Union Party curve with span = 0.09 assigned the color black
  geom_point(aes(x=end_date, y=spd), colour=col_spd, alpha=0.5) + #SPD Party points assigned the color red
  geom_smooth(aes(x=end_date, y=spd), colour=col_spd, span=0.09, se=F) + #SPD Party curve with span = 0.09 assigned the color red
  geom_point(aes(x=end_date, y=af_d), colour=col_af_d, alpha=0.5) + #AfD Party points assigned the color purple
  geom_smooth(aes(x=end_date, y=af_d), colour=col_af_d, span=0.09, se=F) +  #AfD Party curve with span = 0.09 assigned the color purple
  geom_point(aes(x=end_date, y=fdp), colour=col_fdp, alpha=0.5) + #FDP Party points assigned the color yellow
  geom_smooth(aes(x=end_date, y=fdp), colour=col_fdp, span=0.09, se=F) + #FDP Party curve with span = 0.09 assigned the color yellow
  geom_point(aes(x=end_date, y=linke), colour=col_linke, alpha=0.5) + #Linke Party points assigned the color blue
  geom_smooth(aes(x=end_date, y=linke), colour=col_linke, span=0.09, se=F) + #Linke Party curve with span = 0.09 assigned the color blue
  geom_point(aes(x=end_date, y=grune), colour=col_grune, alpha=0.5) + #Grune Party points assigned the color green
  geom_smooth(aes(x=end_date, y=grune), colour=col_grune, span=0.09, se=F) + #Grune Party curve with span = 0.09 assigned the color green
  scale_y_continuous(breaks=seq(0, 40, 10), labels=c('0%', '10%', '20%', '30%', '40%')) + #Adjusting the scale
  geom_hline(yintercept=5, linetype='dashed', color='gray') + 
  scale_color_manual(name='',
                     labels = c('Union', 'SPD', 'AfD', 'FDP', 'Linke', 'Grüne'),
                     values = c('col_union'=col_union,'col_spd'=col_spd,'col_af_d'=col_af_d,'col_fdp'=col_fdp,'col_linke'=col_linke,'col_grune'=col_grune)) + #Creating a legend 
    labs(x='', y='') +
  theme_minimal() + #change theme to be more similar to the original
  theme(legend.background = element_rect(fill=NA, size=.3, linetype="solid")) + #add box around legend to be more similar to the original
  NULL

ggsave(file='elections_plot.png', plot=plot, width=18, height=8)

plot
```

# Details

-   Who did you collaborate with: [Hanlu
    Lin](https://meetlbs.london.edu/network/view/3077/profile), [Hao
    Ni](https://meetlbs.london.edu/network/view/4496/profile), [Junna
    Yanai](https://meetlbs.london.edu/network/view/3097/profile), [Lazar
    Jelic](meetlbs.london.edu/network/view/3158/profile), [Purva
    Sikri](https://meetlbs.london.edu/network/view/268/profile),
    [Valeria
    Morales](https://meetlbs.london.edu/network/view/4886/profile)

-   Approximately how much time did you spend on this problem set: 7
    hours

-   What, if anything, gave you the most trouble: Finding the filtering
    criteria of the election results in the first challenge, Showing a
    chart legend in the second challenge

# Bibliography

Kohli, S. *There are places on earth where and beer are cheaper than water*. Retrieved September 4, 2021,
<https://qz.com/319919/these-are-the-places-on-earth-where-wine-and-beer-are-cheaper-than-water>

Munns, S (2019). *Employee Turnover Rates by Industry Comparison*. Retrieved September 3, 2021, <https://www.e-days.com/news/employee-turnover-rates-an-industry-comparison>

Muster, Hans (2021) Recoil [Source
code](https://gitlab.com/gbuvn1/opinion-polling-graph/-/blob/master/ggplot.R)

Nugent, P. *What Namibia's breweries tell us about the nation's past*.
Retrieved September 4, 2021,
<https://qz.com/africa/1982787/how-namibian-beer-politics-and-identity-all-align>

OECD/The World Bank (2020), *Health at a Glance: Latin America and the Caribbean 2020*, OECD Publishing, Paris,
<https://doi.org/10.1787/6089164f-en>
